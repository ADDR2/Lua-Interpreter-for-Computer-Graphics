<html>
<head>
<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>
<script type="text/javascript" src="Globals.js"></script>
<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;
	
	struct Triangle{
		vec3 Ka;
		vec3 Kd;
		vec3 Ks;
		float Shininess;
		vec3 P1;
		vec3 P2;
		vec3 P3;
	};
	
	struct Plane{
		float Limit;
		vec3 Ka;
		vec3 Kd;
		vec3 Ks;
		float Shininess;
		vec3 Normal;
		int Type;
		vec3 Point;
	};
	
	struct Sphere{
		vec3 Center;
		float R;
		vec3 Color;
		vec3 Ka;
		vec3 Kd;
		vec3 Ks;
		float Shininess;
		bool Light;
	};
	
	uniform Sphere Spheres[6];
	uniform Plane Planes[4];
	uniform Triangle Triangles[8];
	uniform vec3 CameraPos;
	uniform vec3 perspective;
	uniform mat4 invMVMatrix;
    uniform mat4 uPMatrix;
	
	varying vec2 vertex;
	
	bool shadows[3];
	
	
	void Phong(Sphere S, vec3 pos, vec3 n, out vec3 color, vec3 v){
		vec3 s, r, ambient, diffuse, specular;
		color = vec3(0.0,0.0,0.0);
		if(!S.Light){
			for(int i=3; i<6; i++){
				if(shadows[i-3]){
					s = normalize(pos - Spheres[i].Center);
					r = reflect(-s, n);
					
					ambient  =  S.Ka * Spheres[i].Ka;
					diffuse  =  S.Kd * Spheres[i].Kd * max( dot(s,n), 0.0 );
					specular =  S.Ks * Spheres[i].Ks * pow(max(dot(r,v), 0.0),S.Shininess);

					color += ambient + (diffuse + specular);
				}
			}
		}else{
			color += S.Color;
		}
	}
	
	void PhongPlane(Plane P, vec3 pos, vec3 n, out vec3 color, vec3 v){
		vec3 s, r, ambient, diffuse, specular;
		color = vec3(0.0,0.0,0.0);
			for(int i=3; i<6; i++){
				//if(shadows[i-3]){
					s = normalize(pos - Spheres[i].Center);
					r = reflect(-s, n);
					
					ambient  =  P.Ka * Spheres[i].Ka;
					diffuse  =  P.Kd * Spheres[i].Kd * max( dot(s,n), 0.0 );
					specular =  P.Ks * Spheres[i].Ks * pow(max(dot(r,v), 0.0),P.Shininess);

					color += ambient + (diffuse + specular);
				//}
			}
	}
	
	void PhongTriangle(Triangle T, vec3 pos, vec3 n, out vec3 color, vec3 v){
		vec3 s, r, ambient, diffuse, specular;
		color = vec3(0.0,0.0,0.0);
			for(int i=3; i<6; i++){
				s = normalize(pos - Spheres[i].Center);
				r = reflect(-s, n);
				
				ambient  =  T.Ka * Spheres[i].Ka;
				diffuse  =  T.Kd * Spheres[i].Kd * max( dot(s,n), 0.0 );
				specular =  T.Ks * Spheres[i].Ks * pow(max(dot(r,v), 0.0),T.Shininess);

				color += ambient + (diffuse + specular);
			}
	}
	
	bool intersectSphere(vec3 center, vec3 Start, vec3 Dir, float r, out float T) {
		vec3 V = Start - center;
		float A, B, C, R, D, t1, t2;
		B = dot(V,Dir);
		A = dot(Dir,Dir);
		C = (dot(V,V) - r*r);
		if(B*B < A*C) return false;
		D = sqrt(B*B - A*C);
		if(B < 0.0)
			R = -B -D;
		else
			R = -B +D;
		t1 = R/A;
		t2 = C/R;
		if((t1<0.0) || (t2<0.0))
			T = max(max(0.0, t1), max(0.0, t2));
		else
			T = min(max(0.0, t1), max(0.0, t2));
		
		return true;
	}
	
	bool intersectPlane(Plane P, vec3 Start, vec3 Dir, out float t){
		if(dot(P.Normal, Dir)==0.0) return false;
		
		//t = -(dot(P.Normal, Start))/(dot(P.Normal, Dir));
		t = (dot(P.Normal, P.Point - Start))/(dot(P.Normal, Dir));
		
		if(t<0.0) return false;
		
		return true;
	}
	
	bool intersectTriangle(Triangle T, out vec3 normal, out vec3 pos, vec3 Start, vec3 Dir, out float t){
		float s1, s2, s3, u, v, det, inv_det;
		vec3 edge1, edge2, tvec, pvec, qvec;
		
		edge1 = T.P3 - T.P1;
		edge2 = T.P1 - T.P2;
		
		normal.x = edge1.x*edge2.x;
		normal.y = edge1.y*edge2.y;
		normal.z = edge1.z*edge2.z;
		normal = normalize(normal);
		
		pvec.x = Dir.y*edge2.z - Dir.z*edge2.y;
		pvec.y = Dir.z*edge2.x - Dir.x*edge2.z;
		pvec.z = Dir.x*edge2.y - Dir.y*edge2.x;
		
		det = dot(edge1, pvec);
		
		//------------------------------------------------------------------
		
		/*if(det > -0.000001 && det < 0.000001) return false;
		
		tvec = Start - T.P1;
		
		u = dot(tvec, pvec);
		
		if(u < 0.0 || u > det) return false;
		
		qvec.x = tvec.y*edge1.z - tvec.z*edge1.y;
		qvec.y = tvec.z*edge1.x - tvec.x*edge1.z;
		qvec.z = tvec.x*edge1.y - tvec.y*edge1.x;
		
		v = dot(Dir, qvec);
		
		if(v < 0.0 || u + v > det) return false;
		
		t = dot(edge2, qvec);
		
		inv_det = 1.0 / det;
		
		t *= inv_det;
		u *= inv_det;
		v *= inv_det;*/
		
		//--------------------------------------------------------------------
		
		if(det < 0.000001) return false;

		tvec = Start - T.P1;
		
		u = dot(tvec, pvec);
		
		if(u < 0.0 || u > det) return false;
		
		qvec.x = tvec.y*edge1.z - tvec.z*edge1.y;
		qvec.y = tvec.z*edge1.x - tvec.x*edge1.z;
		qvec.z = tvec.x*edge1.y - tvec.y*edge1.x;
		
		v = dot(Dir, qvec);
		
		if(v < 0.0 || u + v > det) return false;
		
		t = dot(edge2, qvec);
		
		inv_det = 1.0 / det;
		
		t *= inv_det;
		u *= inv_det;
		v *= inv_det;
		
		//--------------------------------------------------------------------
		
		pos = (1.0-u-v)*T.P1 + u*T.P2 + v*T.P3;
		
		return true;
	}
	
	bool intersectEscene(vec3 Start, vec3 Dir, out vec3 pos, out vec3 normal, out int Object){
		float tfinal=100000.0, t1, t2;
		for(int i=0; i<6; i++){
			if(intersectSphere(Spheres[i].Center, Start, Dir, Spheres[i].R, t1)){
				if(tfinal > t1){
					Object = i;
					tfinal = t1;
					pos = (Start + Dir * tfinal);
					normal = normalize(pos - Spheres[i].Center);
					//Phong(Spheres[i], pos, normal, color, Dir);
				}
			}
		}
		
		for(int i=0; i<4; i++){
			if(intersectPlane(Planes[i], Start, Dir, t2)){
				if(tfinal > t2){
					Object = i + 6;
					tfinal = t2;
					pos = (Start + Dir * tfinal);
					if((Planes[i].Type==4) && (abs(pos.x) < Planes[i].Limit) && (abs(pos.y) < Planes[i].Limit)){
						normal = Planes[i].Normal;
						//PhongPlane(Planes[i], pos, normal, color, Dir);
					}
					if((Planes[i].Type==3) && (abs(pos.z) < Planes[i].Limit) && (abs(pos.y) < Planes[i].Limit)){
						normal = Planes[i].Normal;
						//PhongPlane(Planes[i], pos, normal, color, Dir);
					}
					if((Planes[i].Type==2) && (abs(pos.z) < Planes[i].Limit) && (abs(pos.y) < Planes[i].Limit)){
						normal = Planes[i].Normal;
						//PhongPlane(Planes[i], pos, normal, color, Dir);
					}
					if((Planes[i].Type==1) && (abs(pos.z) < Planes[i].Limit) && (abs(pos.x) < Planes[i].Limit)){
						normal = Planes[i].Normal;
						//PhongPlane(Planes[i], pos, normal, color, Dir);
					}
					
				}
			}
		}
		
		for(int i=0; i<0; i++){
			if(intersectTriangle(Triangles[i], normal, pos, Start, Dir, t1)){
				if(tfinal > t1){
					Object = i + 10;
					tfinal = t1;
					//PhongTriangle(Triangles[i], pos, normal, color, Dir);
				}
			}
		}
		
		if(tfinal==100000.0){
			return false;
		}

		return true;
	}

    void main(void) {
		vec3 pos1, norm, pos2, colorM = vec3(0.0,0.0,0.0), colorT = vec3(0.0,0.0,0.0), pos3, norm2, colorS1, colorS2, colorS3;
		vec2 vert = vertex;
		float fov = radians(perspective.x);
		float nearPlane  = perspective.z;
		float nearHeight = nearPlane * tan(fov / 2.0);
		float nearWidth  = nearHeight * perspective.y;
		int Object=-1, Object2=-1;
		for(int i=0; i<3; i++){
			shadows[i] = false;
		}
		colorS1 = colorS2 = colorS3 = vec3(0.0,0.0,0.0);
		vert.x *= nearWidth;
		vert.y *= nearHeight;
		vec3 CameraDir = (invMVMatrix * vec4(vert.x, vert.y, -nearPlane, 0.0)).xyz;
		if(intersectEscene(CameraPos, CameraDir, pos1, norm, Object)){
			if(intersectEscene(pos1 + norm*0.1, normalize(Spheres[3].Center - pos1 + norm*0.1), pos3, norm2, Object2) && ((Object2 >= 3 && Object2 < 6)||(Object == Object2))){
				shadows[0] = true;
			}
			if(intersectEscene(pos1 + norm*0.1, normalize(Spheres[4].Center - pos1 + norm*0.1), pos3, norm2, Object2) && ((Object2 >= 3 && Object2 < 6)||(Object == Object2))){
				shadows[1] = true;
			}
			if(intersectEscene(pos1 + norm*0.1, normalize(Spheres[5].Center - pos1 + norm*0.1), pos3, norm2, Object2) && ((Object2 >= 3 && Object2 < 6)||(Object == Object2))){
				shadows[2] = true;
			}
			if(shadows[0] == true || shadows[1] == true || shadows[2] == true){
				if(Object < 6 && Object != -1){
					for(int e=0; e < 6; e++){
						if(e==Object){
							Phong(Spheres[e], pos1, norm, colorM, CameraDir);
						}
					}
				}
				if(Object > 5 && Object < 10 && Object != -1){
					for(int e=0; e < 4; e++){
						if(e==Object-6){
							if((Planes[e].Type==4) && (abs(pos1.x) < Planes[e].Limit) && (abs(pos1.y) < Planes[e].Limit)){
								//norm = Planes[e].Normal;
								PhongPlane(Planes[e], pos1, norm, colorM, CameraDir);
							}
							if((Planes[e].Type==3) && (abs(pos1.z) < Planes[e].Limit) && (abs(pos1.y) < Planes[e].Limit)){
								//norm = Planes[e].Normal;
								PhongPlane(Planes[e], pos1, norm, colorM, CameraDir);
							}
							if((Planes[e].Type==2) && (abs(pos1.z) < Planes[e].Limit) && (abs(pos1.y) < Planes[e].Limit)){
								//norm = Planes[e].Normal;
								PhongPlane(Planes[e], pos1, norm, colorM, CameraDir);
							}
							if((Planes[e].Type==1) && (abs(pos1.z) < Planes[e].Limit) && (abs(pos1.x) < Planes[e].Limit)){
								//norm = Planes[e].Normal;
								PhongPlane(Planes[e], pos1, norm, colorM, CameraDir);
							}
						}
					}
				}
				if(Object > 9 && Object != -1){
					for(int e=0; e < 8; e++){
						if(e==Object-10){
							PhongTriangle(Triangles[e], pos1, norm, colorM, CameraDir);
						}
					}
				}
				colorT = colorM;
				if(Object == 8){
					CameraDir = -refract(CameraDir, norm, 0.8);
				}
				else{
					CameraDir = -reflect(CameraDir, norm);
				}
				if(intersectEscene(pos1 + norm*0.1, CameraDir, pos2, norm, Object)){
					if(Object < 6 && Object != -1){
						for(int e=0; e < 6; e++){
							if(e==Object){
								Phong(Spheres[e], pos2, norm, colorM, CameraDir);
							}
						}
					}
					if(Object > 5 && Object < 10 && Object != -1){
						for(int e=0; e < 4; e++){
							if(e==Object-6){
								if((Planes[e].Type==4) && (abs(pos2.x) < Planes[e].Limit) && (abs(pos2.y) < Planes[e].Limit)){
									norm = Planes[e].Normal;
									PhongPlane(Planes[e], pos2, norm, colorM, CameraDir);
								}
								if((Planes[e].Type==3) && (abs(pos2.z) < Planes[e].Limit) && (abs(pos2.y) < Planes[e].Limit)){
									norm = Planes[e].Normal;
									PhongPlane(Planes[e], pos2, norm, colorM, CameraDir);
								}
								if((Planes[e].Type==2) && (abs(pos2.z) < Planes[e].Limit) && (abs(pos2.y) < Planes[e].Limit)){
									norm = Planes[e].Normal;
									PhongPlane(Planes[e], pos2, norm, colorM, CameraDir);
								}
								if((Planes[e].Type==1) && (abs(pos2.z) < Planes[e].Limit) && (abs(pos2.x) < Planes[e].Limit)){
									norm = Planes[e].Normal;
									PhongPlane(Planes[e], pos2, norm, colorM, CameraDir);
								}
							}
						}
					}
					if(Object > 9 && Object != -1){
						for(int e=0; e < 8; e++){
							if(e==Object-10){
								PhongTriangle(Triangles[e], pos2, norm, colorM, CameraDir);
							}
						}
					}
					colorT = mix(colorT, colorM, 0.3);
				}
				Object2=0;
				for(int i=0; i<3; i++){
					if(!shadows[i]) Object2++;
				}
				if(Object2 > 0){
					colorM = vec3(0.1,0.1,0.1);
					colorT = mix(colorT, colorM, 0.3);
				}
				if(Object2 > 1){
					colorM = vec3(0.1,0.1,0.1);
					colorT = mix(colorT, colorM, 0.3);
				}
			}
			gl_FragColor = vec4(colorT,1.0);
		}else{
			gl_FragColor = vec4(0.0,0.0,0.0,1.0);
		}
    }
</script>
<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec2 aVertexPosition;
	
	varying vec2 vertex;

    void main(void) {
		vertex = aVertexPosition;
        gl_Position = vec4(aVertexPosition, 0.0, 1.0);
    }
</script>
<script type="text/javascript">
	
	function A1(){
		a1=!a1;
	}
	
	function A2(){
		a2=!a2;
	}
	
	function initGL(canvas) {
        try {
            gl = canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }


    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }


    var shaderProgram;

    function initShaders() {
        var fragmentShader = getShader(gl, "shader-fs");
        var vertexShader = getShader(gl, "shader-vs");

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }

        gl.useProgram(shaderProgram);

        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "invMVMatrix");
		CameraPosUniform = gl.getUniformLocation(shaderProgram, "CameraPos");
		PersUniform = gl.getUniformLocation(shaderProgram, "perspective");
		for(var i=0; i<6; i++){
			Sphere = new Object();
			SphereUniform[i] = Sphere;
			SphereUniform[i].Center = gl.getUniformLocation(shaderProgram, "Spheres["+i+"].Center");
			SphereUniform[i].R = gl.getUniformLocation(shaderProgram, "Spheres["+i+"].R");
			SphereUniform[i].Color = gl.getUniformLocation(shaderProgram, "Spheres["+i+"].Color");
			SphereUniform[i].Ka = gl.getUniformLocation(shaderProgram, "Spheres["+i+"].Ka");
			SphereUniform[i].Kd = gl.getUniformLocation(shaderProgram, "Spheres["+i+"].Kd");
			SphereUniform[i].Ks = gl.getUniformLocation(shaderProgram, "Spheres["+i+"].Ks");
			SphereUniform[i].Shininess = gl.getUniformLocation(shaderProgram, "Spheres["+i+"].Shininess");
			SphereUniform[i].Light = gl.getUniformLocation(shaderProgram, "Spheres["+i+"].Light");
		}
		for(var i=0; i<4; i++){
			Plane = new Object();
			PlaneUniform[i] = Plane;
			PlaneUniform[i].Limit = gl.getUniformLocation(shaderProgram, "Planes["+i+"].Limit");
			PlaneUniform[i].Ka = gl.getUniformLocation(shaderProgram, "Planes["+i+"].Ka");
			PlaneUniform[i].Kd = gl.getUniformLocation(shaderProgram, "Planes["+i+"].Kd");
			PlaneUniform[i].Ks = gl.getUniformLocation(shaderProgram, "Planes["+i+"].Ks");
			PlaneUniform[i].Shininess = gl.getUniformLocation(shaderProgram, "Planes["+i+"].Shininess");
			PlaneUniform[i].Normal = gl.getUniformLocation(shaderProgram, "Planes["+i+"].Normal");
			PlaneUniform[i].Type = gl.getUniformLocation(shaderProgram, "Planes["+i+"].Type");
			PlaneUniform[i].Point = gl.getUniformLocation(shaderProgram, "Planes["+i+"].Point");
		}
		for(var i=0; i<8; i++){
			Triangle = new Object();
			TriangleUniform[i] = Triangle;
			TriangleUniform[i].Ka = gl.getUniformLocation(shaderProgram, "Triangles["+i+"].Ka");
			TriangleUniform[i].Kd = gl.getUniformLocation(shaderProgram, "Triangles["+i+"].Kd");
			TriangleUniform[i].Ks = gl.getUniformLocation(shaderProgram, "Triangles["+i+"].Ks");
			TriangleUniform[i].Shininess = gl.getUniformLocation(shaderProgram, "Triangles["+i+"].Shininess");
			TriangleUniform[i].P1 = gl.getUniformLocation(shaderProgram, "Triangles["+i+"].P1");
			TriangleUniform[i].P2 = gl.getUniformLocation(shaderProgram, "Triangles["+i+"].P2");
			TriangleUniform[i].P3 = gl.getUniformLocation(shaderProgram, "Triangles["+i+"].P3");
		}
		
    }

    function setMatrixUniforms() {
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
		gl.uniform3f(CameraPosUniform, CameraPos[0], CameraPos[1], CameraPos[2]);
		gl.uniform3f(PersUniform, Perspective[0], Perspective[1], Perspective[2]);
		for(var i=0; i<6; i++){
			gl.uniform3f(SphereUniform[i].Center, Spheres[i].Center[0], Spheres[i].Center[1], Spheres[i].Center[2]);
			gl.uniform1f(SphereUniform[i].R, Spheres[i].R);
			gl.uniform3f(SphereUniform[i].Color, Spheres[i].Color[0], Spheres[i].Color[1], Spheres[i].Color[2]);
			gl.uniform3f(SphereUniform[i].Ka, Spheres[i].Ka[0], Spheres[i].Ka[1], Spheres[i].Ka[2]);
			gl.uniform3f(SphereUniform[i].Kd, Spheres[i].Kd[0], Spheres[i].Kd[1], Spheres[i].Kd[2]);
			gl.uniform3f(SphereUniform[i].Ks, Spheres[i].Ks[0], Spheres[i].Ks[1], Spheres[i].Ks[2]);
			gl.uniform1f(SphereUniform[i].Shininess, Spheres[i].Shininess);
			gl.uniform1i(SphereUniform[i].Light, Spheres[i].Light);
		}
		for(var i=0; i<4; i++){
			gl.uniform1f(PlaneUniform[i].Limit, Planes[i].Limit);
			gl.uniform3f(PlaneUniform[i].Ka, Planes[i].Ka[0], Planes[i].Ka[1], Planes[i].Ka[2]);
			gl.uniform3f(PlaneUniform[i].Kd, Planes[i].Kd[0], Planes[i].Kd[1], Planes[i].Kd[2]);
			gl.uniform3f(PlaneUniform[i].Ks, Planes[i].Ks[0], Planes[i].Ks[1], Planes[i].Ks[2]);
			gl.uniform1f(PlaneUniform[i].Shininess, Planes[i].Shininess);
			gl.uniform3f(PlaneUniform[i].Normal, Planes[i].Normal[0], Planes[i].Normal[1], Planes[i].Normal[2]);
			gl.uniform1i(PlaneUniform[i].Type, Planes[i].Type);
			gl.uniform3f(PlaneUniform[i].Point, Planes[i].Point[0], Planes[i].Point[1], Planes[i].Point[2]);
		}
		for(var i=0; i<8; i++){
			gl.uniform3f(TriangleUniform[i].Ka, Triangles[i].Ka[0], Triangles[i].Ka[1], Triangles[i].Ka[2]);
			gl.uniform3f(TriangleUniform[i].Kd, Triangles[i].Kd[0], Triangles[i].Kd[1], Triangles[i].Kd[2]);
			gl.uniform3f(TriangleUniform[i].Ks, Triangles[i].Ks[0], Triangles[i].Ks[1], Triangles[i].Ks[2]);
			gl.uniform1f(TriangleUniform[i].Shininess, Triangles[i].Shininess);
			gl.uniform3f(TriangleUniform[i].P1, Triangles[i].P1[0], Triangles[i].P1[1], Triangles[i].P1[2]);
			gl.uniform3f(TriangleUniform[i].P2, Triangles[i].P2[0], Triangles[i].P2[1], Triangles[i].P2[2]);
			gl.uniform3f(TriangleUniform[i].P2, Triangles[i].P3[0], Triangles[i].P3[1], Triangles[i].P3[2]);
		}
    }
	
	


    var triangleVertexPositionBuffer;
    var triangleVertexColorBuffer;
    var squareVertexPositionBuffer;
    var squareVertexColorBuffer;

    function initBuffers() {
        triangleVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
        var vertices = [
             1.0,  1.0,
            -1.0,  1.0,
            -1.0, -1.0,
			-1.0, -1.0,
			 1.0, -1.0,
			 1.0,  1.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        triangleVertexPositionBuffer.itemSize = 2;
        triangleVertexPositionBuffer.numItems = 6;
    }



    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		
		Perspective = vec3.create([45.0,gl.viewportWidth / gl.viewportHeight,0.1]);
		
		pMatrix = mat4.create(mvMatrix);
        mat4.identity(Model);
		View = mat4.lookAt(CameraPos, CameraDir, CameraUp);
		mat4.multiply(View,Model,mvMatrix);
		mat4.inverse(mvMatrix);

        gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

        setMatrixUniforms();
        gl.drawArrays(gl.TRIANGLES, 0, triangleVertexPositionBuffer.numItems);
    }

	function animate() {
        var timeNow = new Date().getTime();
        if (lastTime != 0) {
            var elapsed = timeNow - lastTime;
			
			if(a1){
				if(Spheres[5].Center[2] <= -40.0){ 
					active2=true;
					active1=false;
				}
				
				if(Spheres[5].Center[2] >= 5.0){ 
					active1=true;
					active2=false;
				}
				
				if(active1){
					Spheres[5].Center[2] -= (elapsed/1000.0);
				}
				if(active2){
					Spheres[5].Center[2] += (elapsed/1000.0);
				}
			}
			
			if(a2){
				if(Spheres[3].Center[1] >= 4.0){ 
					active3=true;
					active4=false;
				}
				
				if(Spheres[3].Center[1] <= 0.5){ 
					active4=true;
					active3=false;
				}
				
				if(active3){
					Spheres[3].Center[1] -= (elapsed/1000.0);
					Spheres[4].Center[1] -= (elapsed/1000.0);
				}
				if(active4){
					Spheres[3].Center[1] += (elapsed/1000.0);
					Spheres[4].Center[1] += (elapsed/1000.0);
				}
			}
        }
        lastTime = timeNow;
    }
	
	function Frame(){
		requestAnimFrame(Frame);
		drawScene();
		animate();
	}
	

    function webGLStart() {
        var canvas = document.getElementById("canvas");
        initGL(canvas);
        initShaders();
        initBuffers();

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);
        Frame();
    }

</script>
</head>
<body onload="webGLStart();">
  <center><h1>Trazador de Rayos Web</h1></center>
  <center><canvas id="canvas" style="border: none;" width="1024" height="1024"></canvas></center>
  <center><button Onclick="A1()">Animaci&#243n 1</button>
  <button Onclick="A2()">Animaci&#243n 2</button></center>
  <center><img src="picture11.jpg"></center>
  <center><img src="picture22.jpg"></center>
  <center><img src="picture33.jpg"></center>
  <center><img src="picture44.jpg"></center>
  <center><img src="picture55.jpg"></center>
  <center><h3>Explicaci&#243n</h3></center>
  <center>Esta escena contiene esferas y planos, uno de los planos refracta la luz y las otras figuras
  la reflejan. Tambi&#233n posee el efecto de sombra generado por cada luz sobre cada objeto o figura,
  as&#237 como tambi&#233n el efecto de luz generado por cada luz. Por &#250ltimo esta p&#225gina permite
  activar y desactivar un par de animaciones.</center>
  <center><h3>Cr&#233ditos</h3></center>
  <center>Amaro Duarte</center>
</body>
</html>