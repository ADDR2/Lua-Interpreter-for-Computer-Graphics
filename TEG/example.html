<html>
	<head>
		<title>TEG</title>
		<script type='text/javascript' src='glMatrix-0.9.5.min.js'></script>
		<script type='text/javascript' src='webgl-utils.js'></script>
		<script id='shader-vColorNormal' type='x-shader/x-vertex'>
			attribute vec3 aVertexPosition;
		    attribute vec3 aVertexNormal;
		    attribute vec2 aTextureCoord;

		    uniform mat4 uVMatrix;
		    uniform mat4 uPMatrix;
		    uniform mat4 uMMatrix;
		    uniform mat3 uNMatrix;

		    varying vec3 vNormal;

		    void main(void) {
		        gl_Position = uPMatrix * uVMatrix * uMMatrix * vec4(aVertexPosition, 1.0);
		        vNormal = uNMatrix * aVertexNormal;
		    }
		</script>
		<script id='shader-fColorNormal' type='x-shader/x-fragment'>
			precision mediump float;

			varying vec3 vNormal;

		    void main(void) {
		    	gl_FragColor = vec4(vNormal, 1.0);
		    }
		</script>
		<script id='shader-fPhong' type='x-shader/x-fragment'>
		    precision mediump float;

		    struct pointLight{
				vec3 center;
				vec3 la;
				vec3 ld;
				vec3 ls;
			};

			struct dirLight{
				vec3 center;
				vec3 dir;
				vec3 la;
				vec3 ld;
				vec3 ls;
			};

			struct spotLight{
				vec3 center;
				vec3 dir;
				vec3 la;
				vec3 ld;
				vec3 ls;
				float cutoff;
				float exponent;
			};

			struct material{
				vec3 ka;
				vec3 kd;
				vec3 ks;
				float shininess;
			};

			uniform material mat;
			uniform vec3 cameraPos;
			uniform pointLight pLights[1];
			uniform dirLight dLights[1];
			uniform spotLight spLights[1];
		    varying vec3 vNormal;
		    varying vec3 position;

		    void main(void) {
		    	vec3 n = normalize(vNormal);
				vec3 v = normalize(vec3(cameraPos) - position);
				vec3 color = vec3(0.0,0.0,0.0);

				for(int i=0; i<0; i++)
				{
				
					vec3 s = normalize(pLights[i].center - position);
					vec3 r = reflect(-s, n);
					
					vec3 ambient  =  mat.ka * pLights[i].la;
					vec3 diffuse  =  mat.kd * pLights[i].ld * max( dot(s,n), 0.0 );
					vec3 specular =  mat.ks * pLights[i].ls * pow(max(dot(r,v), 0.0),mat.shininess);
					
					color += ambient + diffuse + specular;
				}

				for(int j=0; j<0; j++)
				{
					vec3 s = normalize(spLights[j].center - position);
					
					float angle = dot(-s,spLights[j].dir);
					float cutoff = spLights[j].cutoff;
					
					vec3 ambient = mat.ka * spLights[j].la;
					
					if(angle > cutoff)
					{
					
						float fDif = 1.0 - cutoff;
						float fFactor = clamp((angle-cutoff)/fDif, 0.0, 1.0);
						
						float spotFactor = pow(fFactor,spLights[j].exponent);
						vec3 r = reflect(-s, n);
						vec3 diffuse  =  spotFactor * mat.kd * spLights[j].ld * max( dot(s, n), 0.0 );
						vec3 specular =  mat.ks * spLights[j].ls * pow(max(dot(r,v), 0.0), mat.shininess);
						
						color += ambient + diffuse + specular;
					}else
						color += ambient;
				}

				for(int k=0; k<0; k++)
				{
					vec3 s = normalize(dLights[k].dir);
					vec3 r = reflect(-s, n);
						
					vec3 ambient  =  mat.ka * dLights[k].la;
					vec3 diffuse  =  mat.kd * dLights[k].ld * max( dot(s,n), 0.0 );
					vec3 specular =  mat.ks * dLights[k].ls * pow(max(dot(r,v), 0.0),mat.shininess);
						
					color += ambient + diffuse + specular;
				}
	
		    	gl_FragColor = vec4(color, 1.0);
		    	
		    }
		</script>
		<script id='shader-vPhong' type='x-shader/x-vertex'>
		    attribute vec3 aVertexPosition;
		    attribute vec3 aVertexNormal;
		    attribute vec2 aTextureCoord;

		    uniform mat4 uVMatrix;
		    uniform mat4 uPMatrix;
		    uniform mat4 uMMatrix;
		    uniform mat3 uNMatrix;

		    varying vec3 vNormal;
		    varying vec3 position;

		    void main(void) {
		        gl_Position = uPMatrix * uVMatrix * uMMatrix * vec4(aVertexPosition, 1.0);
		        position = vec3(uMMatrix * vec4(aVertexPosition, 1.0));
		        vNormal = uNMatrix * aVertexNormal;
		    }
		</script>
		<script id='shader-fFlat' type='x-shader/x-fragment'>
		    precision mediump float;

		    
		    varying vec3 frontColor;
		    varying vec3 backColor;

		    void main(void){
	
		    	if( gl_FrontFacing ) {
					gl_FragColor = vec4(frontColor, 1.0);
				} else {
					gl_FragColor = vec4(backColor, 1.0);
				}
		    	
		    }
		</script>
		<script id='shader-vFlat' type='x-shader/x-vertex'>
		    attribute vec3 aVertexPosition;
		    attribute vec3 aVertexNormal;
		    attribute vec2 aTextureCoord;

		    struct pointLight{
				vec3 center;
				vec3 la;
				vec3 ld;
				vec3 ls;
			};

			struct dirLight{
				vec3 center;
				vec3 dir;
				vec3 la;
				vec3 ld;
				vec3 ls;
			};

			struct spotLight{
				vec3 center;
				vec3 dir;
				vec3 la;
				vec3 ld;
				vec3 ls;
				float cutoff;
				float exponent;
			};

			struct material{
				vec3 ka;
				vec3 kd;
				vec3 ks;
				float shininess;
			};

		    uniform mat4 uVMatrix;
		    uniform mat4 uPMatrix;
		    uniform mat4 uMMatrix;
		    uniform mat3 uNMatrix;

			uniform material mat;
			uniform vec3 cameraPos;
			uniform pointLight pLights[1];
			uniform dirLight dLights[1];
			uniform spotLight spLights[1];

		    varying vec3 frontColor;
			varying vec3 backColor;

		    void main(void) {

		    	vec3 position = vec3(uMMatrix * vec4(aVertexPosition, 1.0));
		    	vec3 vNormal = uNMatrix * aVertexNormal;
		    	vec3 n = normalize(vNormal);
		    	vec3 inverseN = -n;
				vec3 v = normalize(vec3(cameraPos) - position);
				vec3 color = vec3(0.0,0.0,0.0);
				vec3 inverseColor = vec3(0.0,0.0,0.0);

				for(int i=0; i<0; i++)
				{
					
					vec3 s = normalize(pLights[i].center - position);
					vec3 r = reflect(-s, n);
						
					vec3 ambient  =  mat.ka * pLights[i].la;
					vec3 diffuse  =  mat.kd * pLights[i].ld * max( dot(s,n), 0.0 );
					vec3 specular =  mat.ks * pLights[i].ls * pow(max(dot(r,v), 0.0),mat.shininess);
						
					color += ambient + diffuse + specular;

					diffuse = mat.kd * pLights[i].ld * max( dot(s,inverseN), 0.0 );
					specular =  mat.ks * pLights[i].ls * pow(max(dot(reflect(-s, inverseN),v), 0.0),mat.shininess);

					inverseColor += ambient + diffuse + specular;
				}

				for(int j=0; j<0; j++)
				{
					vec3 s = normalize(spLights[j].center - position);
						
					float angle = dot(-s,spLights[j].dir);
					float cutoff = spLights[j].cutoff;
						
					vec3 ambient = mat.ka * spLights[j].la;
						
					if(angle > cutoff)
					{
						
						float fDif = 1.0 - cutoff;
						float fFactor = clamp((angle-cutoff)/fDif, 0.0, 1.0);
							
						float spotFactor = pow(fFactor,spLights[j].exponent);
						vec3 r = reflect(-s, n);
						vec3 diffuse  =  spotFactor * mat.kd * spLights[j].ld * max( dot(s, n), 0.0 );
						vec3 specular =  mat.ks * spLights[j].ls * pow(max(dot(r,v), 0.0), mat.shininess);
							
						color += ambient + diffuse + specular;

						diffuse = spotFactor * mat.kd * spLights[j].ld * max( dot(s, inverseN), 0.0 );
						specular =  mat.ks * spLights[j].ls * pow(max(dot(reflect(-s, inverseN),v), 0.0),mat.shininess);

						inverseColor += ambient + diffuse + specular;
					}else{
						color += ambient;
						inverseColor += ambient;
					}
				}

				for(int k=0; k<0; k++)
				{
					vec3 s = normalize(dLights[k].dir);
					vec3 r = reflect(-s, n);
							
					vec3 ambient  =  mat.ka * dLights[k].la;
					vec3 diffuse  =  mat.kd * dLights[k].ld * max( dot(s,n), 0.0 );
					vec3 specular =  mat.ks * dLights[k].ls * pow(max(dot(r,v), 0.0),mat.shininess);
							
					color += ambient + diffuse + specular;

					diffuse = mat.kd * dLights[k].ld * max( dot(s,inverseN), 0.0 );
					specular =  mat.ks * dLights[k].ls * pow(max(dot(reflect(-s, inverseN),v), 0.0),mat.shininess);

					inverseColor += ambient + diffuse + specular;
				}

		        gl_Position = uPMatrix * uVMatrix * uMMatrix * vec4(aVertexPosition, 1.0);
		        frontColor = color;
		        backColor = inverseColor;
		    }
		</script>
		<script>
			var gl;
			var shaderProgram = [];
			var currentModel = 'None';
			var currentShader = 2;
			var objMaterial = new Object();
			var isALightTheLastDisplay = 0;
			var DisplayArray = new Array();
			var arrayLights = new Array();
			var arrayDirLights = new Array();
			var arraySpotLights = new Array();
			function initScene(){
				currentShader = shaderProgram.length-1;
				currentModel = 'None';
				gl.useProgram(shaderProgram[currentShader]);
				DisplayArray = new Array();
				arrayLights = new Array();
				arrayDirLights = new Array();
			    arraySpotLights = new Array();
			}
			function degToRad(degrees) {
			    return degrees * Math.PI / 180;
			}
		</script>
		<script>
			function loadDoc(file, verts, norms, coords, center, flatNorms) {
			  var xhttp = new XMLHttpRequest();
			  xhttp.open('GET', file, false);
			  xhttp.send();
			    if(xhttp.responseText != ''){
			        compileObjModel(xhttp.responseText, verts, norms, coords, center, flatNorms);
			        return true;
			    }
			    console.log('El archivo '+file+' no se encontro o no contiene nada');
			    return false;
			}


			function store(line, array, limit){
			    var nonSpace = /[^\t\s\v\0]/;
			    var helper = [];
			    var cont = 0;
			    helper = line.split(/[\t\s\v\0]/);
			    for (var j = 0; j < helper.length && cont < limit; j++){
			        if(nonSpace.test(helper[j])){
			            var c = Number(helper[j]);
			            if(!isNaN(c)){
			                array.push(c);
			                cont++;
			            }
			        }
			    }
			}

			function compileObjModel(fileText, iVerts, iNorms, iCoords, center,flatNorms){
			    var lines = fileText.split('\n');
			    var nonIndex = /[^0-9\/]/;
			    var number = /[0-9]/;
			    var vertex = /[v][\s\t\v\0]/;
			    var normal = /[v][n][\s\t\v\0]/;
			    var texCoord = /[v][t][\s\t\v\0]/;
			    var index = /[f][\s\t\v\0]/
			    var verts = [];
			    var normals = [];
			    var texCoords = [];
			    var indexes = [];
			    
			    var max_x = -Number.MAX_VALUE;
			    var max_y = -Number.MAX_VALUE;
			    var max_z = -Number.MAX_VALUE;
			    var min_x = Number.MAX_VALUE;
			    var min_y = Number.MAX_VALUE;
			    var min_z = Number.MAX_VALUE;
			    for (var i = 0; i < lines.length; i++){
			        if(vertex.test(lines[i]))
			            store(lines[i], verts, 3);

			        if(normal.test(lines[i]))
			            store(lines[i], normals, 3);

			        if(texCoord.test(lines[i]))
			            store(lines[i], texCoords, 2);

			        if(index.test(lines[i])){
			            lines[i] = lines[i].split(/[\t\s\v\0]/);
			            var cont = 0;
			            var ind = iVerts.length-1;
			            var ind_cond = iCoords.length-1;
			            for (var j = 0; j < lines[i].length; j++){
			                if(!nonIndex.test(lines[i][j]) && number.test(lines[i][j][0])){
			                    var helper = lines[i][j].split('/');
			                    if(cont < 3){
			                        if(helper != lines[i][j]){
			                            if (number.test(helper[0])){
			                                iVerts.push(verts[(Number(helper[0])-1)*3]);
			                                iVerts.push(verts[(Number(helper[0])-1)*3+1]);
			                                iVerts.push(verts[(Number(helper[0])-1)*3+2]);

			                                if(iVerts[iVerts.length-3] > max_x)
			                                    max_x = iVerts[iVerts.length-3];
			                                if(iVerts[iVerts.length-2] > max_y)
			                                    max_y = iVerts[iVerts.length-2];
			                                if(iVerts[iVerts.length-1] > max_z)
			                                    max_z = iVerts[iVerts.length-1];
			                                if(iVerts[iVerts.length-3] < min_x)
			                                    min_x = iVerts[iVerts.length-3];
			                                if(iVerts[iVerts.length-2] < min_y)
			                                    min_y = iVerts[iVerts.length-2];
			                                if(iVerts[iVerts.length-1] < min_z)
			                                    min_z = iVerts[iVerts.length-1];
			                            }
			                                //iVerts.push(Number(helper[0])-1);
			                            if (number.test(helper[1])){
			                                iCoords.push(texCoords[(Number(helper[1])-1)*2]);
			                                iCoords.push(texCoords[(Number(helper[1])-1)*2+1]);
			                            }

			                            if (helper.length >= 3 && number.test(helper[2])){
			                                iNorms.push(normals[(Number(helper[2])-1)*3]);
			                                iNorms.push(normals[(Number(helper[2])-1)*3+1]);
			                                iNorms.push(normals[(Number(helper[2])-1)*3+2]);
			                            }

			                        }else{
			                            iVerts.push(verts[(Number(lines[i][j])-1)*3]);
			                            iVerts.push(verts[(Number(lines[i][j])-1)*3+1]);
			                            iVerts.push(verts[(Number(lines[i][j])-1)*3+2]);

			                            if(iVerts[iVerts.length-3] > max_x)
			                                max_x = iVerts[iVerts.length-3];
			                            if(iVerts[iVerts.length-2] > max_y)
			                                max_y = iVerts[iVerts.length-2];
			                            if(iVerts[iVerts.length-1] > max_z)
			                                max_z = iVerts[iVerts.length-1];
			                            if(iVerts[iVerts.length-3] < min_x)
			                                min_x = iVerts[iVerts.length-3];
			                            if(iVerts[iVerts.length-2] < min_y)
			                                min_y = iVerts[iVerts.length-2];
			                            if(iVerts[iVerts.length-1] < min_z)
			                                min_z = iVerts[iVerts.length-1];
			                        }
			                    }else{
			                        if(helper != lines[i][j]){
			                            if (number.test(helper[0])){
			                                iVerts.push(iVerts[ind+1]);
			                                iVerts.push(iVerts[ind+2]);
			                                iVerts.push(iVerts[ind+3]);

			                                iVerts.push(iVerts[iVerts.length-6]);
			                                iVerts.push(iVerts[iVerts.length-6]);
			                                iVerts.push(iVerts[iVerts.length-6]);

			                                iVerts.push(verts[(Number(helper[0])-1)*3]);
			                                iVerts.push(verts[(Number(helper[0])-1)*3+1]);
			                                iVerts.push(verts[(Number(helper[0])-1)*3+2]);

			                                if(iVerts[iVerts.length-3] > max_x)
			                                    max_x = iVerts[iVerts.length-3];
			                                if(iVerts[iVerts.length-2] > max_y)
			                                    max_y = iVerts[iVerts.length-2];
			                                if(iVerts[iVerts.length-1] > max_z)
			                                    max_z = iVerts[iVerts.length-1];
			                                if(iVerts[iVerts.length-3] < min_x)
			                                    min_x = iVerts[iVerts.length-3];
			                                if(iVerts[iVerts.length-2] < min_y)
			                                    min_y = iVerts[iVerts.length-2];
			                                if(iVerts[iVerts.length-1] < min_z)
			                                    min_z = iVerts[iVerts.length-1];
			                            }
			                                //iVerts.push(Number(helper[0])-1);
			                            if (number.test(helper[1])){
			                                iCoords.push(iCoords[ind_cond+1]);
			                                iCoords.push(iCoords[ind_cond+2]);

			                                iCoords.push(iCoords[iCoords.length-4]);
			                                iCoords.push(iCoords[iCoords.length-4]);

			                                iCoords.push(texCoords[(Number(helper[1])-1)*2]);
			                                iCoords.push(texCoords[(Number(helper[1])-1)*2+1]);
			                            }

			                            if (helper.length >= 3 && number.test(helper[2])){
			                                iNorms.push(iNorms[ind+1]);
			                                iNorms.push(iNorms[ind+2]);
			                                iNorms.push(iNorms[ind+3]);

			                                iNorms.push(iNorms[iNorms.length-6]);
			                                iNorms.push(iNorms[iNorms.length-6]);
			                                iNorms.push(iNorms[iNorms.length-6]);

			                                iNorms.push(normals[(Number(helper[2])-1)*3]);
			                                iNorms.push(normals[(Number(helper[2])-1)*3+1]);
			                                iNorms.push(normals[(Number(helper[2])-1)*3+2]);
			                            }

			                        }else{
			                            iVerts.push(iVerts[ind+1]);
			                            iVerts.push(iVerts[ind+2]);
			                            iVerts.push(iVerts[ind+3]);

			                            iVerts.push(iVerts[iVerts.length-6]);
			                            iVerts.push(iVerts[iVerts.length-6]);
			                            iVerts.push(iVerts[iVerts.length-6]);

			                            iVerts.push(verts[(Number(lines[i][j])-1)*3]);
			                            iVerts.push(verts[(Number(lines[i][j])-1)*3+1]);
			                            iVerts.push(verts[(Number(lines[i][j])-1)*3+2]);

			                            if(iVerts[iVerts.length-3] > max_x)
			                                max_x = iVerts[iVerts.length-3];
			                            if(iVerts[iVerts.length-2] > max_y)
			                                max_y = iVerts[iVerts.length-2];
			                            if(iVerts[iVerts.length-1] > max_z)
			                                max_z = iVerts[iVerts.length-1];
			                            if(iVerts[iVerts.length-3] < min_x)
			                                min_x = iVerts[iVerts.length-3];
			                            if(iVerts[iVerts.length-2] < min_y)
			                                min_y = iVerts[iVerts.length-2];
			                            if(iVerts[iVerts.length-1] < min_z)
			                                min_z = iVerts[iVerts.length-1];
			                        }
			                    }
			                    cont++;
			                    if((iVerts.length/3)%3 == 0){
			                        var v1 = [];
			                        var v2 = [];
			                        var v3 = [];
			                        v1.push(iVerts[iVerts.length-9]);
			                        v1.push(iVerts[iVerts.length-8]);
			                        v1.push(iVerts[iVerts.length-7]);
			                        v2.push(iVerts[iVerts.length-6]);
			                        v2.push(iVerts[iVerts.length-5]);
			                        v2.push(iVerts[iVerts.length-4]);
			                        v3.push(iVerts[iVerts.length-3]);
			                        v3.push(iVerts[iVerts.length-2]);
			                        v3.push(iVerts[iVerts.length-1]);
			                        var V1 = [v1[0]-v2[0], v1[1]-v2[1], v1[2]-v2[2]];
			                        var V2 = [v1[0]-v3[0], v1[1]-v3[1], v1[2]-v3[2]];
			                        var V = [V1[1] * V2[2] - V1[2] * V2[1], V1[2] * V2[0] - V1[0] * V2[2], V1[0] * V2[1] - V1[1] * V2[0]];
			                        var len = Math.sqrt(V[0]*V[0]+V[1]*V[1]+V[2]*V[2]);
			                        V = [V[0]/len, V[1]/len, V[2]/len];
			                        for(var k = iVerts.length-9; k < iVerts.length; k+=3){
			                            flatNorms[k] = V[0];
			                            flatNorms[k+1] = V[1];
			                            flatNorms[k+2] = V[2];
			                            if(!('('+iVerts[k]+','+iVerts[k+1]+','+iVerts[k+2]+')' in indexes)){
			                                indexes['('+iVerts[k]+','+iVerts[k+1]+','+iVerts[k+2]+')'] = {faces: [], inds: []};
			                                indexes['('+iVerts[k]+','+iVerts[k+1]+','+iVerts[k+2]+')'].faces.push(V);
			                                indexes['('+iVerts[k]+','+iVerts[k+1]+','+iVerts[k+2]+')'].inds.push(k);
			                            }else{
			                                indexes['('+iVerts[k]+','+iVerts[k+1]+','+iVerts[k+2]+')'].faces.push(V);
			                                indexes['('+iVerts[k]+','+iVerts[k+1]+','+iVerts[k+2]+')'].inds.push(k);
			                            }
			                        }
			                    }
			                }
			            }
			        }
			    }
			    for(var k in indexes){
			        var norm = [0, 0, 0];
			        for(var q = 0; q < indexes[k].faces.length; q++){
			            norm[0] += indexes[k].faces[q][0];
			            norm[1] += indexes[k].faces[q][1];
			            norm[2] += indexes[k].faces[q][2];
			        }
			        norm[0] = norm[0]/indexes[k].faces.length;
			        norm[1] = norm[1]/indexes[k].faces.length;
			        norm[2] = norm[2]/indexes[k].faces.length;
			        for (var q = 0; q < indexes[k].inds.length; q++){
			            iNorms[indexes[k].inds[q]] = norm[0];
			            iNorms[indexes[k].inds[q]+1] = norm[1];
			            iNorms[indexes[k].inds[q]+2] = norm[2];
			        }
			    }
			    center.push((max_x+min_x)/2);
			    center.push((max_y+min_y)/2);
			    center.push((max_z+min_z)/2);
			    console.log('El centro es: '+((max_x+min_x)/2) +' ,'+ ((max_y+min_y)/2) +' ,'+((max_z+min_z)/2));
			    console.log('verts: '+iVerts.length);
			    console.log('norms: '+iNorms.length);
			    console.log('flatnorms: '+flatNorms.length);
			    console.log('coords: '+iCoords.length);
			}
		</script>
		<script>
			var cameraReady = false;
			var currentlyPressedKeys = {};
			var cursorPosX;
			var cursorPosY;
			var lastPosX = -9000;
			var lastPosY = -9000;
			var currentRotX = -0.01;
			var lastRotX = 0.0;

			function handleKeyDown(event) {
			    console.log(event.keyCode);
			    if(cameraReady)
					currentlyPressedKeys[event.keyCode] = true;
			}


			function handleKeyUp(event) {
			    currentlyPressedKeys[event.keyCode] = false;
			}

			function handleMouseDown (event){
			    if(event.button == 1){
			        cameraReady = !cameraReady;
			    }
			}

			function handleMouseMove(event) {

				var canvas = document.getElementById('lesson04-canvas');

			    cursorPosX = event.x - canvas.offsetLeft;
			    cursorPosY = event.y - canvas.offsetTop;
			    //console.log('X: '+cursorPosX+' ,Y: '+cursorPosY);
			}


			var camera = new Object();

			camera.position = vec3.create([0.0,0.0,0.0]);
			camera.view = vec3.create([0.0,0.0,0.0]);
			camera.upVector = vec3.create([0.0,0.0,0.0]);
			camera.strafe = vec3.create([0.0,0.0,0.0]);
			camera.frameInterval = 0.0;
			camera.frameTime = 0.0;
			camera.viewMatrix = mat4.create();
			mat4.identity(camera.viewMatrix);

			camera.calculateFrameRate = function(){
				var currentTime = new Date().getTime();				
			 	camera.frameInterval = currentTime - camera.frameTime;
				camera.frameTime = currentTime;
			}

			camera.changeAttributes = function(pos, view, up){
				camera.position = vec3.create(pos);
				//console.log(camera.position[0]);
				camera.view = vec3.create(view);
				camera.upVector = vec3.create(up);
			}

			function convertQuaternionToMatrix3(quat, mode){
				var mat = mat3.create();
			    var yy2 = 2.0 * quat[1] * quat[1];
			    var xy2 = 2.0 * quat[0] * quat[1];
			    var xz2 = 2.0 * quat[0] * quat[2];
			    var yz2 = 2.0 * quat[1] * quat[2];
			    var zz2 = 2.0 * quat[2] * quat[2];
			    var wz2 = 2.0 * quat[3] * quat[2];
			    var wy2 = 2.0 * quat[3] * quat[1];
			    var wx2 = 2.0 * quat[3] * quat[0];
			    var xx2 = 2.0 * quat[0] * quat[0];
			    mat[0] = - yy2 - zz2 + 1.0;
			    mat[1] = xy2 - mode * wz2;
			    mat[2] = xz2 + mode * wy2;
			    mat[3] = xy2 + mode * wz2;
			    mat[4] = - xx2 - zz2 + 1.0;
			    mat[5] = yz2 - mode * wx2;
			    mat[6] = xz2 - mode * wy2;
			    mat[7] = yz2 + mode * wx2;
			    mat[9] = - xx2 - yy2 + 1.0;
				return mat;
			}

			function setQuaternionFromAxisAngle(axis, angle){
				var quat = quat4.create();
			    var sina2;
			    sina2 = Math.sin(0.5 * angle);
			    quat[0] = sina2 * axis[0];
			    quat[1] = sina2 * axis[1];
			    quat[2] = sina2 * axis[2];
			    quat[3] = Math.cos(0.5 * angle);
			    //console.log('quat: '+quat4.str(quat));
				return quat;
			}

			function multiplyVec3ByMat3(vec, mat){
				var result = vec3.create();
				result[0] = vec[0]*mat[0] + vec[1]*mat[1] + vec[2]*mat[2];
				result[1] = vec[0]*mat[3] + vec[1]*mat[4] + vec[2]*mat[5];
				result[2] = vec[0]*mat[6] + vec[1]*mat[7] + vec[2]*mat[8];
				return result;
			}

			camera.setViewByMouse = function(){								
				var middleX = gl.viewportWidth / 2;			
				var middleY = gl.viewportHeight / 2;				
				var angleY = 0.0;
				var angleZ = 0.0;

				//if((prevx == middleX) && (prevy == middleY)) return;


				angleY = ( (middleX - cursorPosX) ) / 5000.0;		
				angleZ = ( (middleY - cursorPosY) ) / 5000.0;		

				lastRotX = currentRotX;

				currentRotX += angleZ;
				
				var axis = vec3.create();
				vec3.cross(vec3.create([camera.view[0] - camera.position[0],camera.view[1] - camera.position[1],camera.view[2] - camera.position[2]]), camera.upVector, axis);
				vec3.normalize(axis);
				vec3.negate(axis);

				if(currentRotX > 0.5){
					currentRotX = 0.5 ;
					if(lastRotX != 0.5 )
						camera.rotateView(0.5  - lastRotX, axis);

				}else if(currentRotX < -0.5){
					currentRotX = -0.5;
					if(lastRotX != -0.5)
						camera.rotateView(-0.5 - lastRotX, axis);

				}else
			        camera.rotateView(angleZ, axis);
				//mat4.rotate(camera.viewMatrix, angleY, [0, 1, 0]);
				camera.rotateView(angleY, [0, -1, 0]);
			}

			camera.rotateView = function(degrees, dir){
				var view = vec3.create([camera.view[0]-camera.position[0],camera.view[1]-camera.position[1],camera.view[2]-camera.position[2]]);		
				var quat = quat4.create(setQuaternionFromAxisAngle(dir, degrees));
				//console.log('quat2: '+quat4.str(quat));
				var mat = mat4.create();
				quat4.toMat4(quat, mat);
				//console.log('mat: '+mat3.str(mat));

				var newView = vec3.create();
				mat4.multiplyVec3(mat, view, newView);

				//console.log('viewVec: '+vec3.str(newView));
				camera.view = vec3.create([camera.position[0]+newView[0],camera.position[1]+newView[1],camera.position[2]+newView[2]]);
			}

			camera.strafeCamera = function(speed){	
				camera.position[0] += camera.strafe[0] * speed;
				camera.position[2] += camera.strafe[2] * speed;

				camera.view[0] += camera.strafe[0] * speed;
				camera.view[2] += camera.strafe[2] * speed;
			}

			camera.moveCamera = function(speed){
				var vector = vec3.create([camera.view[0] - camera.position[0],camera.view[1] - camera.position[1],camera.view[2] - camera.position[2]]);
				vec3.normalize(vector);

				camera.position[0] += vector[0] * speed;		
				camera.position[1] += vector[1] * speed;		
				camera.position[2] += vector[2] * speed;		
				camera.view[0] += vector[0] * speed;		
				camera.view[1] += vector[1] * speed;		
				camera.view[2] += vector[2] * speed;		
			}

			camera.checkForMovement = function(){	
				var speed = camera.frameInterval / 100.0;

				if (currentlyPressedKeys[38] || currentlyPressedKeys[87])
			        camera.moveCamera(speed);

			    if (currentlyPressedKeys[40] || currentlyPressedKeys[83])
			        camera.moveCamera(-speed);

			    if (currentlyPressedKeys[37] || currentlyPressedKeys[65])
			        camera.strafeCamera(-speed);

			    if (currentlyPressedKeys[39] || currentlyPressedKeys[68])
			        camera.strafeCamera(speed);
			    //console.log(mat4.str(camera.viewMatrix));
			}

			camera.update = function(){

				var cross = vec3.create();
				vec3.cross(vec3.create([camera.view[0] - camera.position[0],camera.view[1] - camera.position[1],camera.view[2] - camera.position[2]]), camera.upVector, cross);

				vec3.normalize(cross, camera.strafe);

				if(cameraReady && (cursorPosX != lastPosX || cursorPosY != lastPosY))
					camera.setViewByMouse();

				lastPosX = cursorPosX;
				lastPosY = cursorPosY;

				camera.checkForMovement();

				camera.calculateFrameRate();
			}

			camera.look = function(){
				//console.log(camera.position[0]);
				mat4.lookAt(camera.position, camera.view, camera.upVector, camera.viewMatrix);
			}
		</script>
		<script>
			function InitObj(obj, verts, smoothNorms, coords, center, flatNorms){
		    obj.objVertexPositionBuffer = 0;
		    obj.objVertexNormalBuffer = 0;
		    obj.objVertexIndexBuffer = 0;
		    obj.modelMatrix = mat4.create();
		    mat4.identity(obj.modelMatrix);
		    obj.normalMatrix = mat3.create();
		    mat3.identity(obj.normalMatrix);
		    obj.center = center;
		    obj.ka = vec3.create([0.4,0.4,0.4]);
		    obj.kd = vec3.create([0.5,0.5,0.5]);
		    obj.ks = vec3.create([0.6,0.6,0.6]);
		    obj.shininess = 0.65;

		    obj.vertices = verts;

		    obj.flatNormals = flatNorms;
		    obj.smoothNormals = smoothNorms;

		    obj.coords = coords;


		    obj.InitBuffers = function (){
		        obj.objVertexPositionBuffer = gl.createBuffer();
		            gl.bindBuffer(gl.ARRAY_BUFFER, obj.objVertexPositionBuffer);
		            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(obj.vertices), gl.STATIC_DRAW);
		            obj.objVertexPositionBuffer.itemSize = 3;
		            obj.objVertexPositionBuffer.numItems = obj.vertices.length/3;

		            obj.objVertexFlatNormalBuffer = gl.createBuffer();
		            gl.bindBuffer(gl.ARRAY_BUFFER, obj.objVertexFlatNormalBuffer);
		            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(obj.flatNormals), gl.STATIC_DRAW);
		            obj.objVertexFlatNormalBuffer.itemSize = 3;
		            obj.objVertexFlatNormalBuffer.numItems = obj.flatNormals.length/3;

		            obj.objVertexSmoothNormalBuffer = gl.createBuffer();
		            gl.bindBuffer(gl.ARRAY_BUFFER, obj.objVertexSmoothNormalBuffer);
		            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(obj.smoothNormals), gl.STATIC_DRAW);
		            obj.objVertexSmoothNormalBuffer.itemSize = 3;
		            obj.objVertexSmoothNormalBuffer.numItems = obj.smoothNormals.length/3;

		        };

		    obj.Display = function (shaderProgram, vMatrix, pMatrix, material){
		            mat4.toInverseMat3(obj.modelMatrix, obj.normalMatrix);
		            mat3.transpose(obj.normalMatrix);
		            gl.bindBuffer(gl.ARRAY_BUFFER, obj.objVertexPositionBuffer);
		            gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, obj.objVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

		            if(currentModel == 'Flat'){
		                //console.log('hola');
		                gl.bindBuffer(gl.ARRAY_BUFFER, obj.objVertexFlatNormalBuffer);
		                gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, obj.objVertexFlatNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
		            }else{
		                gl.bindBuffer(gl.ARRAY_BUFFER, obj.objVertexSmoothNormalBuffer);
		                gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, obj.objVertexSmoothNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
		            }

		            gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
		            gl.uniformMatrix4fv(shaderProgram.vMatrixUniform, false, vMatrix);
		            gl.uniformMatrix4fv(shaderProgram.mMatrixUniform, false, obj.modelMatrix);
		            gl.uniformMatrix3fv(shaderProgram.nMatrixUniform, false, obj.normalMatrix);

		            if(currentShader < 2){
		                gl.uniform3f(material.ka, obj.ka[0], obj.ka[1], obj.ka[2]);
		                gl.uniform3f(material.kd, obj.kd[0], obj.kd[1], obj.kd[2]);
		                gl.uniform3f(material.ks, obj.ks[0], obj.ks[1], obj.ks[2]);
		                gl.uniform1f(material.shininess, obj.shininess);
		            }
		            gl.drawArrays(gl.TRIANGLES, 0, obj.vertices.length/3);
		        };

		    obj.Translate = function (tVector){
		        mat4.translate(obj.modelMatrix, tVector);
		    }

		    obj.Rotate = function (degrees, dir){
		        mat4.translate(obj.modelMatrix, [-obj.center[0], -obj.center[1], -obj.center[2]]);
		        mat4.rotate(obj.modelMatrix, degrees, dir);
		        mat4.translate(obj.modelMatrix, obj.center);
		    }

		    obj.Scale = function (sVector){
		        mat4.scale(obj.modelMatrix, sVector);
		    }
		}
		</script>
		<script>
		    function initGL(canvas) {
		        try {
		            gl = canvas.getContext('experimental-webgl');
		            gl.viewportWidth = canvas.width;
		            gl.viewportHeight = canvas.height;
		        } catch (e) {
		        }
		        if (!gl) {
		            alert('Could not initialise WebGL, sorry :-(');
		        }
		    }


		    function getShader(gl, id) {
		        var shaderScript = document.getElementById(id);
		        if (!shaderScript) {
		            return null;
		        }

		        var str = '';
		        var k = shaderScript.firstChild;
		        while (k) {
		            if (k.nodeType == 3) {
		                str += k.textContent;
		            }
		            k = k.nextSibling;
		        }
		        var shader;
		        if (shaderScript.type == 'x-shader/x-fragment') {
		            shader = gl.createShader(gl.FRAGMENT_SHADER);
		        } else if (shaderScript.type == 'x-shader/x-vertex') {
		            shader = gl.createShader(gl.VERTEX_SHADER);
		        } else {
		            return null;
		        }

		        gl.shaderSource(shader, str);
		        gl.compileShader(shader);

		        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
		            alert(gl.getShaderInfoLog(shader));
		            return null;
		        }

		        return shader;
		    }

		    function initShaders() {
		        //currentShader = 2;
		        var fragmentShader = getShader(gl, 'shader-fPhong');
		        var vertexShader = getShader(gl, 'shader-vPhong');

		        shaderProgram[0] = gl.createProgram();
		        gl.attachShader(shaderProgram[0], vertexShader);
		        gl.attachShader(shaderProgram[0], fragmentShader);
		        gl.linkProgram(shaderProgram[0]);

		        if (!gl.getProgramParameter(shaderProgram[0], gl.LINK_STATUS)) {
		            alert('Could not initialise shaders');
		        }

		        gl.useProgram(shaderProgram[0]);

		        shaderProgram[0].vertexPositionAttribute = gl.getAttribLocation(shaderProgram[0], 'aVertexPosition');
		        gl.enableVertexAttribArray(shaderProgram[0].vertexPositionAttribute);

		        shaderProgram[0].vertexNormalAttribute = gl.getAttribLocation(shaderProgram[0], 'aVertexNormal');
		        gl.enableVertexAttribArray(shaderProgram[0].vertexNormalAttribute);

		        shaderProgram[0].textureCoordAttribute = gl.getAttribLocation(shaderProgram[0], 'aTextureCoord');
		        gl.enableVertexAttribArray(shaderProgram[0].textureCoordAttribute);

		        shaderProgram[0].pMatrixUniform = gl.getUniformLocation(shaderProgram[0], 'uPMatrix');
		        shaderProgram[0].vMatrixUniform = gl.getUniformLocation(shaderProgram[0], 'uVMatrix');
		        shaderProgram[0].mMatrixUniform = gl.getUniformLocation(shaderProgram[0], 'uMMatrix');
		        shaderProgram[0].nMatrixUniform = gl.getUniformLocation(shaderProgram[0], 'uNMatrix');
		        shaderProgram[0].cameraPosUniform = gl.getUniformLocation(shaderProgram[0], 'cameraPos');
		        shaderProgram[0].objMaterial = new Object();
		        shaderProgram[0].objMaterial.ka = gl.getUniformLocation(shaderProgram[0], 'mat.ka');
		        shaderProgram[0].objMaterial.kd = gl.getUniformLocation(shaderProgram[0], 'mat.kd');
		        shaderProgram[0].objMaterial.ks = gl.getUniformLocation(shaderProgram[0], 'mat.ks');
		        shaderProgram[0].objMaterial.shininess = gl.getUniformLocation(shaderProgram[0], 'mat.shininess');

		        shaderProgram[0].lightUniforms = [];
		        for(var i=0; i<arrayLights.length; i++){
		            shaderProgram[0].lightUniforms[i] = new Object();
		            shaderProgram[0].lightUniforms[i].center = gl.getUniformLocation(shaderProgram[0], 'pLights['+i+'].center');
		            shaderProgram[0].lightUniforms[i].la = gl.getUniformLocation(shaderProgram[0], 'pLights['+i+'].la');
		            shaderProgram[0].lightUniforms[i].ld = gl.getUniformLocation(shaderProgram[0], 'pLights['+i+'].ld');
		            shaderProgram[0].lightUniforms[i].ls = gl.getUniformLocation(shaderProgram[0], 'pLights['+i+'].ls');
		        }

		        shaderProgram[0].dirLightUniforms = [];
		        for(var i=0; i<arrayDirLights.length; i++){
		            shaderProgram[0].dirLightUniforms[i] = new Object();
		            shaderProgram[0].dirLightUniforms[i].center = gl.getUniformLocation(shaderProgram[0], 'dLights['+i+'].center');
		            shaderProgram[0].dirLightUniforms[i].dir = gl.getUniformLocation(shaderProgram[0], 'dLights['+i+'].dir');
		            shaderProgram[0].dirLightUniforms[i].la = gl.getUniformLocation(shaderProgram[0], 'dLights['+i+'].la');
		            shaderProgram[0].dirLightUniforms[i].ld = gl.getUniformLocation(shaderProgram[0], 'dLights['+i+'].ld');
		            shaderProgram[0].dirLightUniforms[i].ls = gl.getUniformLocation(shaderProgram[0], 'dLights['+i+'].ls');
		        }

		        shaderProgram[0].spotLightUniforms = [];
		        for(var i=0; i<arraySpotLights.length; i++){
		            shaderProgram[0].spotLightUniforms[i] = new Object();
		            shaderProgram[0].spotLightUniforms[i].center = gl.getUniformLocation(shaderProgram[0], 'spLights['+i+'].center');
		            shaderProgram[0].spotLightUniforms[i].dir = gl.getUniformLocation(shaderProgram[0], 'spLights['+i+'].dir');
		            shaderProgram[0].spotLightUniforms[i].la = gl.getUniformLocation(shaderProgram[0], 'spLights['+i+'].la');
		            shaderProgram[0].spotLightUniforms[i].ld = gl.getUniformLocation(shaderProgram[0], 'spLights['+i+'].ld');
		            shaderProgram[0].spotLightUniforms[i].ls = gl.getUniformLocation(shaderProgram[0], 'spLights['+i+'].ls');
		            shaderProgram[0].spotLightUniforms[i].cutoff = gl.getUniformLocation(shaderProgram[0], 'spLights['+i+'].cutoff');
		            shaderProgram[0].spotLightUniforms[i].exponent = gl.getUniformLocation(shaderProgram[0], 'spLights['+i+'].exponent');
		        }

		        fragmentShader = getShader(gl, 'shader-fFlat');
		        vertexShader = getShader(gl, 'shader-vFlat');

		        shaderProgram[1] = gl.createProgram();
		        gl.attachShader(shaderProgram[1], vertexShader);
		        gl.attachShader(shaderProgram[1], fragmentShader);
		        gl.linkProgram(shaderProgram[1]);

		        if (!gl.getProgramParameter(shaderProgram[1], gl.LINK_STATUS)) {
		            alert('Could not initialise shaders');
		        }

		        gl.useProgram(shaderProgram[1]);

		        shaderProgram[1].vertexPositionAttribute = gl.getAttribLocation(shaderProgram[1], 'aVertexPosition');
		        gl.enableVertexAttribArray(shaderProgram[1].vertexPositionAttribute);

		        shaderProgram[1].vertexNormalAttribute = gl.getAttribLocation(shaderProgram[1], 'aVertexNormal');
		        gl.enableVertexAttribArray(shaderProgram[1].vertexNormalAttribute);

		        shaderProgram[1].textureCoordAttribute = gl.getAttribLocation(shaderProgram[1], 'aTextureCoord');
		        gl.enableVertexAttribArray(shaderProgram[1].textureCoordAttribute);

		        shaderProgram[1].pMatrixUniform = gl.getUniformLocation(shaderProgram[1], 'uPMatrix');
		        shaderProgram[1].vMatrixUniform = gl.getUniformLocation(shaderProgram[1], 'uVMatrix');
		        shaderProgram[1].mMatrixUniform = gl.getUniformLocation(shaderProgram[1], 'uMMatrix');
		        shaderProgram[1].nMatrixUniform = gl.getUniformLocation(shaderProgram[1], 'uNMatrix');
		        shaderProgram[1].cameraPosUniform = gl.getUniformLocation(shaderProgram[1], 'cameraPos');
		        shaderProgram[1].objMaterial = new Object();
		        shaderProgram[1].objMaterial.ka = gl.getUniformLocation(shaderProgram[1], 'mat.ka');
		        shaderProgram[1].objMaterial.kd = gl.getUniformLocation(shaderProgram[1], 'mat.kd');
		        shaderProgram[1].objMaterial.ks = gl.getUniformLocation(shaderProgram[1], 'mat.ks');
		        shaderProgram[1].objMaterial.shininess = gl.getUniformLocation(shaderProgram[1], 'mat.shininess');

		        shaderProgram[1].lightUniforms = [];
		        for(var i=0; i<arrayLights.length; i++){
		            shaderProgram[1].lightUniforms[i] = new Object();
		            shaderProgram[1].lightUniforms[i].center = gl.getUniformLocation(shaderProgram[1], 'pLights['+i+'].center');
		            shaderProgram[1].lightUniforms[i].la = gl.getUniformLocation(shaderProgram[1], 'pLights['+i+'].la');
		            shaderProgram[1].lightUniforms[i].ld = gl.getUniformLocation(shaderProgram[1], 'pLights['+i+'].ld');
		            shaderProgram[1].lightUniforms[i].ls = gl.getUniformLocation(shaderProgram[1], 'pLights['+i+'].ls');
		        }

		        shaderProgram[1].dirLightUniforms = [];
		        for(var i=0; i<arrayDirLights.length; i++){
		            shaderProgram[1].dirLightUniforms[i] = new Object();
		            shaderProgram[1].dirLightUniforms[i].center = gl.getUniformLocation(shaderProgram[1], 'dLights['+i+'].center');
		            shaderProgram[1].dirLightUniforms[i].dir = gl.getUniformLocation(shaderProgram[1], 'dLights['+i+'].dir');
		            shaderProgram[1].dirLightUniforms[i].la = gl.getUniformLocation(shaderProgram[1], 'dLights['+i+'].la');
		            shaderProgram[1].dirLightUniforms[i].ld = gl.getUniformLocation(shaderProgram[1], 'dLights['+i+'].ld');
		            shaderProgram[1].dirLightUniforms[i].ls = gl.getUniformLocation(shaderProgram[1], 'dLights['+i+'].ls');
		        }

		        shaderProgram[1].spotLightUniforms = [];
		        for(var i=0; i<arraySpotLights.length; i++){
		            shaderProgram[1].spotLightUniforms[i] = new Object();
		            shaderProgram[1].spotLightUniforms[i].center = gl.getUniformLocation(shaderProgram[1], 'spLights['+i+'].center');
		            shaderProgram[1].spotLightUniforms[i].dir = gl.getUniformLocation(shaderProgram[1], 'spLights['+i+'].dir');
		            shaderProgram[1].spotLightUniforms[i].la = gl.getUniformLocation(shaderProgram[1], 'spLights['+i+'].la');
		            shaderProgram[1].spotLightUniforms[i].ld = gl.getUniformLocation(shaderProgram[1], 'spLights['+i+'].ld');
		            shaderProgram[1].spotLightUniforms[i].ls = gl.getUniformLocation(shaderProgram[1], 'spLights['+i+'].ls');
		            shaderProgram[1].spotLightUniforms[i].cutoff = gl.getUniformLocation(shaderProgram[1], 'spLights['+i+'].cutoff');
		            shaderProgram[1].spotLightUniforms[i].exponent = gl.getUniformLocation(shaderProgram[1], 'spLights['+i+'].exponent');
		        }

		        fragmentShader = getShader(gl, 'shader-fColorNormal');
		        vertexShader = getShader(gl, 'shader-vColorNormal');
		        shaderProgram[2] = gl.createProgram();
		        gl.attachShader(shaderProgram[2], vertexShader);
		        gl.attachShader(shaderProgram[2], fragmentShader);
		        gl.linkProgram(shaderProgram[2]);

		        if (!gl.getProgramParameter(shaderProgram[2], gl.LINK_STATUS)) {
		            alert('Could not initialise shaders');
		        }

		        gl.useProgram(shaderProgram[2]);

		        shaderProgram[2].vertexPositionAttribute = gl.getAttribLocation(shaderProgram[2], 'aVertexPosition');
		        gl.enableVertexAttribArray(shaderProgram[2].vertexPositionAttribute);

		        shaderProgram[2].vertexNormalAttribute = gl.getAttribLocation(shaderProgram[2], 'aVertexNormal');
		        gl.enableVertexAttribArray(shaderProgram[2].vertexNormalAttribute);

		        shaderProgram[2].textureCoordAttribute = gl.getAttribLocation(shaderProgram[2], 'aTextureCoord');
		        gl.enableVertexAttribArray(shaderProgram[2].textureCoordAttribute);

		        shaderProgram[2].pMatrixUniform = gl.getUniformLocation(shaderProgram[2], 'uPMatrix');
		        shaderProgram[2].vMatrixUniform = gl.getUniformLocation(shaderProgram[2], 'uVMatrix');
		        shaderProgram[2].mMatrixUniform = gl.getUniformLocation(shaderProgram[2], 'uMMatrix');
		        shaderProgram[2].nMatrixUniform = gl.getUniformLocation(shaderProgram[2], 'uNMatrix');
		    }

		    var pMatrix = mat4.create();
		    var rPyramid = 0;
		    var rCube = 0;

		    function drawScene() {
		        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
		        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

		        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
		        camera.look();

		        for (var key in DisplayArray){

		            DisplayArray[key].Rotate(degToRad(rCube), [1, 1, 1]);
		            DisplayArray[key].Display(shaderProgram[currentShader], camera.viewMatrix, pMatrix, shaderProgram[currentShader].objMaterial);

		        }

		    }


		    var lastTime = 0;
		    var joggingAngle = 0;

		    function animate() {
		        var timeNow = new Date().getTime();
		        if (lastTime != 0) {
		            var elapsed = timeNow - lastTime;

		            rPyramid += (90 * elapsed) / 1000.0;
		            rCube = (75 * elapsed) / 1000.0;
		            var elapsed = timeNow - lastTime;
		        }
		        lastTime = timeNow;
		    }


		    function tick() {
		        requestAnimFrame(tick);
		        drawScene();
		        camera.update();
		        animate();
		    }


		    function webGLStart() {
		        var canvas = document.getElementById('lesson04-canvas');
		        initGL(canvas);
		        initShaders();
		        camera.changeAttributes([0, 0, -7], [0, 0, 0], [0, 1, 0]);

		        gl.clearColor(0.0, 0.0, 0.0, 1.0);
		        gl.enable(gl.DEPTH_TEST);

		        document.onkeydown = handleKeyDown;
		        document.onkeyup = handleKeyUp;
		        document.onmousedown = handleMouseDown;
		        canvas.onmousemove = handleMouseMove;
		        initScene();

		        tick();
		    }
		</script>
		<script>
			function initScene(){
				var  verts = [];
				var  norms = [];
				var  coords = [];
				var  center = [];
				var  flatNorms = [];
				if(loadDoc('engine.obj', verts, norms, coords, center, flatNorms)){
					var Obj = new Object();
					InitObj(Obj, verts, norms, coords, center, flatNorms);
					var aux = Obj.center;
					aux[0] = -aux[0];
					aux[1] = -aux[1];
					aux[2] = -aux[2];
					Obj.Translate(aux);
					Obj.InitBuffers();
					DisplayArray.push(Obj);
					isALightTheLastDisplay = 0;
				}

			}
		</script>
	</head>
	<body onload='webGLStart();' id = 'body'>
	    <canvas id='lesson04-canvas' style='border: none;' width='500' height='500'></canvas>
	</body>
</html>